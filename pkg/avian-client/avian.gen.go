// Code generated by oto; DO NOT EDIT.

package avian

import (
	"bytes"
	"compress/gzip"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strings"

	datastore "github.com/avian-digital-forensics/auto-processing/pkg/datastore"
	"github.com/pkg/errors"
)

// Client is used to access Pace services.
type Client struct {
	// RemoteHost is the URL of the remote server that this Client should
	// access.
	RemoteHost string
	// HTTPClient is the http.Client to use when making HTTP requests.
	HTTPClient *http.Client
	// Debug writes a line of debug log output.
	Debug func(s string)
	// secret is the Secret to make the HMAC signature
	secret []byte
}

// New makes a new Client.
func New(remoteHost, secret string) *Client {
	return &Client{
		RemoteHost: remoteHost,
		Debug:      func(s string) {},
		// No timeout is set to HTTPClient
		// since some operations takes too long
		HTTPClient: &http.Client{},
		secret:     []byte(secret),
	}
}

// NmsService handles the Nuix Management Servers
type NmsService struct {
	client *Client
}

// NewNmsService makes a new client for accessing NmsService services.
func NewNmsService(client *Client) *NmsService {
	return &NmsService{
		client: client,
	}
}

func (s *NmsService) Apply(ctx context.Context, r NmsApplyRequests) (*NmsApplyResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.Apply: marshal NmsApplyRequests")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.Apply: generate signature NmsApplyRequests")
	}
	url := s.client.RemoteHost + "NmsService.Apply"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.Apply: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.Apply")
	}
	defer resp.Body.Close()
	var response struct {
		NmsApplyResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "NmsService.Apply: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.Apply: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("NmsService.Apply: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.NmsApplyResponse, nil
}

func (s *NmsService) List(ctx context.Context, r NmsListRequest) (*NmsListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.List: marshal NmsListRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.List: generate signature NmsListRequest")
	}
	url := s.client.RemoteHost + "NmsService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.List: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.List")
	}
	defer resp.Body.Close()
	var response struct {
		NmsListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "NmsService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.List: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("NmsService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.NmsListResponse, nil
}

func (s *NmsService) ListLicences(ctx context.Context, r NmsListLicencesRequest) (*NmsListLicencesResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.ListLicences: marshal NmsListLicencesRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.ListLicences: generate signature NmsListLicencesRequest")
	}
	url := s.client.RemoteHost + "NmsService.ListLicences"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.ListLicences: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.ListLicences")
	}
	defer resp.Body.Close()
	var response struct {
		NmsListLicencesResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "NmsService.ListLicences: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.ListLicences: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("NmsService.ListLicences: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.NmsListLicencesResponse, nil
}

// RunnerService handles all the runners
type RunnerService struct {
	client *Client
}

// NewRunnerService makes a new client for accessing RunnerService services.
func NewRunnerService(client *Client) *RunnerService {
	return &RunnerService{
		client: client,
	}
}

// Apply applies the configuration to the backend
func (s *RunnerService) Apply(ctx context.Context, r RunnerApplyRequest) (*RunnerApplyResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Apply: marshal RunnerApplyRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Apply: generate signature RunnerApplyRequest")
	}
	url := s.client.RemoteHost + "RunnerService.Apply"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Apply: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Apply")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerApplyResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.Apply: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Apply: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.Apply: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerApplyResponse, nil
}

// FailedStage sets a stage to Failed
func (s *RunnerService) FailedStage(ctx context.Context, r StageRequest) (*StageResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FailedStage: marshal StageRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FailedStage: generate signature StageRequest")
	}
	url := s.client.RemoteHost + "RunnerService.FailedStage"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FailedStage: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FailedStage")
	}
	defer resp.Body.Close()
	var response struct {
		StageResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.FailedStage: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FailedStage: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.FailedStage: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.StageResponse, nil
}

// FinishStage sets a stage to Finished
func (s *RunnerService) FinishStage(ctx context.Context, r StageRequest) (*StageResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FinishStage: marshal StageRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FinishStage: generate signature StageRequest")
	}
	url := s.client.RemoteHost + "RunnerService.FinishStage"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FinishStage: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FinishStage")
	}
	defer resp.Body.Close()
	var response struct {
		StageResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.FinishStage: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FinishStage: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.FinishStage: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.StageResponse, nil
}

// Get returns the requested Runner
func (s *RunnerService) Get(ctx context.Context, r RunnerGetRequest) (*RunnerGetResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Get: marshal RunnerGetRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Get: generate signature RunnerGetRequest")
	}
	url := s.client.RemoteHost + "RunnerService.Get"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Get: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Get")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerGetResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.Get: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Get: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.Get: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerGetResponse, nil
}

// List returns the runners from the backend
func (s *RunnerService) List(ctx context.Context, r RunnerListRequest) (*RunnerListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.List: marshal RunnerListRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.List: generate signature RunnerListRequest")
	}
	url := s.client.RemoteHost + "RunnerService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.List: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.List")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.List: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerListResponse, nil
}

// StartStage sets a stage to Active
func (s *RunnerService) StartStage(ctx context.Context, r StageRequest) (*StageResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.StartStage: marshal StageRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.StartStage: generate signature StageRequest")
	}
	url := s.client.RemoteHost + "RunnerService.StartStage"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.StartStage: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.StartStage")
	}
	defer resp.Body.Close()
	var response struct {
		StageResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.StartStage: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.StartStage: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.StartStage: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.StageResponse, nil
}

// ServerService handles all the servers
type ServerService struct {
	client *Client
}

// NewServerService makes a new client for accessing ServerService services.
func NewServerService(client *Client) *ServerService {
	return &ServerService{
		client: client,
	}
}

func (s *ServerService) Apply(ctx context.Context, r ServerApplyRequest) (*ServerApplyResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.Apply: marshal ServerApplyRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.Apply: generate signature ServerApplyRequest")
	}
	url := s.client.RemoteHost + "ServerService.Apply"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.Apply: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.Apply")
	}
	defer resp.Body.Close()
	var response struct {
		ServerApplyResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "ServerService.Apply: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.Apply: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("ServerService.Apply: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.ServerApplyResponse, nil
}

func (s *ServerService) List(ctx context.Context, r ServerListRequest) (*ServerListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.List: marshal ServerListRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.List: generate signature ServerListRequest")
	}
	url := s.client.RemoteHost + "ServerService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.List: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.List")
	}
	defer resp.Body.Close()
	var response struct {
		ServerListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "ServerService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.List: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("ServerService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.ServerListResponse, nil
}

// Case holds the information for a case
type Case struct {
	datastore.Base

	// Name of the case
	Name string `json:"name" yaml:"name"`

	// Directory of the case
	Directory string `json:"directory" yaml:"directory"`

	// Description of the case
	Description string `json:"description" yaml:"description"`

	// Investigator of the case
	Investigator string `json:"investigator" yaml:"investigator"`
}

// CaseSettings holds information about the cases if Processing-stage is used for a
// Runner
type CaseSettings struct {
	datastore.Base

	// CaseLocation is the parent-folder for all cases
	CaseLocation string `json:"caseLocation" yaml:"caseLocation"`

	// Case holds the information for the single-case
	CaseID uint `json:"caseID" yaml:"caseID"`

	Case *Case `json:"case" yaml:"case"`

	// CompoundCase holds the information for the compound-case
	CompoundCaseID uint `json:"compoundCaseID" yaml:"compoundCaseID"`

	CompoundCase *Case `json:"compoundCase" yaml:"compoundCase"`

	// ReviewCompound holds the information for the review-compound
	ReviewCompoundID uint `json:"reviewCompoundID" yaml:"reviewCompoundID"`

	ReviewCompound *Case `json:"reviewCompound" yaml:"reviewCompound"`
}

// Evidence holds information about a specific evidence
type Evidence struct {
	datastore.Base

	// ProcessID foreign-key for process-table
	ProcessID uint `json:"processID" yaml:"processID"`

	// Name of the evidence
	Name string `json:"name" yaml:"name"`

	// Directory of where the evidence is located
	Directory string `json:"directory" yaml:"directory"`

	// Description of the evidence
	Description string `json:"description" yaml:"description"`

	// Encoding for the evidence (used when processing)
	Encoding string `json:"encoding" yaml:"encoding"`

	// TimeZone for the evidence
	TimeZone string `json:"timeZone" yaml:"timeZone"`

	// Custodian for the evidence
	Custodian string `json:"custodian" yaml:"custodian"`

	// Locale for the evidence (used when processing)
	Locale string `json:"locale" yaml:"locale"`
}

// Exclude excludes items in a Nuix-case based on a search
type Exclude struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Search query in the case
	Search string `json:"search" yaml:"search"`

	// Reason to exclude the items from the search
	Reason string `json:"reason" yaml:"reason"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// File holds information about a file
type File struct {
	datastore.Base

	// SearchAndTagID foreign-key for searchandtag-table
	SearchAndTagID uint `json:"searchAndTagID" yaml:"searchAndTagID"`

	// Path for where the file is located at
	Path string `json:"path" yaml:"path"`
}

// Licence holds information about licences in Nuix Management Server
type Licence struct {
	datastore.Base

	// Foreign-key for the NMS-server
	NmsID uint `json:"nmsID" yaml:"nmsID"`

	// Type of licence
	Type string `json:"type" yaml:"type"`

	// Amount of licences for this type
	Amount int64 `json:"amount" yaml:"amount"`

	// Amount of licenses in use for this type
	InUse int64 `json:"inUse" yaml:"inUse"`
}

// LicenceApplyRequest is the input-object for applying NMS-licence
type LicenceApplyRequest struct {

	// Type of licence
	Type string `json:"type" yaml:"type"`

	// Amount of licences for this type
	Amount int64 `json:"amount" yaml:"amount"`
}

// Licences is a holder for Licence
type Licences struct {
	Licence LicenceApplyRequest `json:"licence" yaml:"licence"`
}

// Nms is the main struct for the Nuix Management Servers
type Nms struct {
	datastore.Base

	// Address of the nms-server
	Address string `json:"address" yaml:"address"`

	// Port for the nms-server
	Port int64 `json:"port" yaml:"port"`

	// Username for the nms-server
	Username string `json:"username" yaml:"username"`

	// Password for the nms-server
	Password string `json:"password" yaml:"password"`

	// amount of workers licensed to the server
	Workers int64 `json:"workers" yaml:"workers"`

	// Amount of workers in use
	InUse int64 `json:"inUse" yaml:"inUse"`

	// Licences available at the server
	Licences []Licence `json:"licences" yaml:"licences"`
}

// NmsApplyRequest is the input-object for Apply in the NMS-service
type NmsApplyRequest struct {

	// Address of the nms-server
	Address string `json:"address" yaml:"address"`

	// Port for the nms-server
	Port int64 `json:"port" yaml:"port"`

	// Username for the nms-server
	Username string `json:"username" yaml:"username"`

	// Password for the nms-server
	Password string `json:"password" yaml:"password"`

	// amount of workers licensed to the server
	Workers int64 `json:"workers" yaml:"workers"`

	// Licences available at the server
	Licences []Licences `json:"licences" yaml:"licences"`
}

type NmsApplyRequests struct {
	Nms []NmsApplyRequest `json:"nms" yaml:"nms"`
}

// NmsApplyResponse is the output-object for Apply in the NMS-service
type NmsApplyResponse struct {
	Nms []Nms `json:"nms" yaml:"nms"`
}

// NmsListLicencesRequest is the input-object for listing licences for a specific
// NMS
type NmsListLicencesRequest struct {

	// ID for the nms-server to list the licences for
	NmsID uint `json:"nmsID" yaml:"nmsID"`
}

// NmsListLicencesResponse is the output-object for listing licences for a specific
// NMS
type NmsListLicencesResponse struct {
	Licences []Licence `json:"licences" yaml:"licences"`
}

// NmsListRequest is the input-object for List in the NMS-service
type NmsListRequest struct {
}

// NmsListResponse is the output-object for List in the NMS-service
type NmsListResponse struct {
	Nms []Nms `json:"nms" yaml:"nms"`
}

// Ocr performs OCR based on a search in a Nuix-case
type Ocr struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Profile for the ocr-processor
	Profile string `json:"profile" yaml:"profile"`

	ProfilePath string `json:"profilePath" yaml:"profilePath"`

	// Search query in the case
	Search string `json:"search" yaml:"search"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Populate populates data based on a search in a Nuix-case
type Populate struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Search query in the case
	Search string `json:"search" yaml:"search"`

	// Types for the items to populate
	Types []*Type `json:"types" yaml:"types"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Process -stage processes data into a Nuix-case
type Process struct {
	datastore.Base

	// Foreign-key for stage
	StageID uint `json:"stageID" yaml:"stageID"`

	// Profile for the processor
	Profile string `json:"profile" yaml:"profile"`

	ProfilePath string `json:"profilePath" yaml:"profilePath"`

	// EvidenceStore to process to the nuix-case
	EvidenceStore []*Evidence `json:"evidenceStore" yaml:"evidenceStore"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Reload reloads items in a Nuix-case based on a search
type Reload struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Profile for the reload-processing
	Profile string `json:"profile" yaml:"profile"`

	ProfilePath string `json:"profilePath" yaml:"profilePath"`

	// Search query in the case
	Search string `json:"search" yaml:"search"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Runner holds the information for a specific runner
type Runner struct {
	datastore.Base

	// Name for the runner
	Name string `json:"name" yaml:"name"`

	// Server to use for the runner
	Hostname string `json:"hostname" yaml:"hostname"`

	// Nms to use for the runner
	Nms string `json:"nms" yaml:"nms"`

	// Licence to use for the runner
	Licence string `json:"licence" yaml:"licence"`

	// Xmx to use for the runner
	Xmx string `json:"xmx" yaml:"xmx"`

	// Amount of workers to use for the runner
	Workers int64 `json:"workers" yaml:"workers"`

	// Active - if the runner is active or not
	Active bool `json:"active" yaml:"active"`

	// Finished - if the runner has finished or not
	Finished bool `json:"finished" yaml:"finished"`

	// CaseSettings for the cases to use
	CaseSettingsID uint `json:"caseSettingsID" yaml:"caseSettingsID"`

	CaseSettings *CaseSettings `json:"caseSettings" yaml:"caseSettings"`

	// Stages for the runner
	Stages []*Stage `json:"stages" yaml:"stages"`
}

// RunnerApplyRequest is the input-object for applying a runner-configuration to
// the Runner-service
type RunnerApplyRequest struct {

	// Name for the runner
	Name string `json:"name" yaml:"name"`

	// Server to use for the runner
	Hostname string `json:"hostname" yaml:"hostname"`

	// Nms to use for the runner
	Nms string `json:"nms" yaml:"nms"`

	// Licence to use for the runner
	Licence string `json:"licence" yaml:"licence"`

	// Xmx to use for the runner
	Xmx string `json:"xmx" yaml:"xmx"`

	// Amount of workers to use for the runner
	Workers int64 `json:"workers" yaml:"workers"`

	// CaseSettings is the settings for the cases that should be processed if
	// Process-stage is used
	CaseSettings *CaseSettings `json:"caseSettings" yaml:"caseSettings"`

	// Stages for the runner
	Stages []*Stage `json:"stages" yaml:"stages"`
}

// RunnerApplyResponse is the output-object for applying a runner-configuration to
// the backend
type RunnerApplyResponse struct {
	Runner Runner `json:"runner" yaml:"runner"`
}

// RunnerGetRequest is the input-object for requesting a runner by name
type RunnerGetRequest struct {
	Name string `json:"name" yaml:"name"`
}

// RunnerGetResponse is the output-object for requesting a runner by name
type RunnerGetResponse struct {
	Runner Runner `json:"runner" yaml:"runner"`
}

// RunnerListRequest is the input-object for listing the runners from the backend
type RunnerListRequest struct {
}

// RunnerListResponse is the input-object for listing the runners from the backend
type RunnerListResponse struct {
	Runners []Runner `json:"runners" yaml:"runners"`
}

type StageRequest struct {
	StageID uint `json:"stageID" yaml:"stageID"`
}

// Stage holds different types of stages for a Runner
type Stage struct {
	datastore.Base

	// Foreign-key for runners
	RunnerID uint `json:"runnerID" yaml:"runnerID"`

	// Process-stage processes data into a Nuix-case
	Process *Process `json:"process" yaml:"process"`

	// SearchAndTag searches and tags data in a Nuix-case
	SearchAndTag *SearchAndTag `json:"searchAndTag" yaml:"searchAndTag"`

	// Populate populates data based on a search in a Nuix-case
	Populate *Populate `json:"populate" yaml:"populate"`

	// Ocr performs OCR based on a search in a Nuix-case
	Ocr *Ocr `json:"ocr" yaml:"ocr"`

	// Exclude excludes items in a Nuix-case based on a search
	Exclude *Exclude `json:"exclude" yaml:"exclude"`

	// Reload reloads items in a Nuix-case based on a search
	Reload *Reload `json:"reload" yaml:"reload"`
}

type StageResponse struct {
	Stage Stage `json:"stage" yaml:"stage"`
}

// SearchAndTag searches and tags data in a Nuix-case
type SearchAndTag struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Search query in the case
	Search string `json:"search" yaml:"search"`

	// Tag for the items from the search
	Tag string `json:"tag" yaml:"tag"`

	// Files for the search-and-tag
	Files []*File `json:"files" yaml:"files"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Server is the main-struct for the servers
type Server struct {
	datastore.Base

	// Hostname of the server
	Hostname string `json:"hostname" yaml:"hostname"`

	// Port for the server
	Port int64 `json:"port" yaml:"port"`

	// OperatingSystem the server is running
	OperatingSystem string `json:"operatingSystem" yaml:"operatingSystem"`

	// Username for connection to the server
	Username string `json:"username" yaml:"username"`

	// Password for connection to the server
	Password string `json:"password" yaml:"password"`

	// NuixPath to know where to run Nuix
	NuixPath string `json:"nuixPath" yaml:"nuixPath"`

	// Active - if the server has an active job
	Active bool `json:"active" yaml:"active"`
}

// ServerApplyRequest is the input-object for Apply in the server-service
type ServerApplyRequest struct {
	Hostname string `json:"hostname" yaml:"hostname"`

	Port int64 `json:"port" yaml:"port"`

	OperatingSystem string `json:"operatingSystem" yaml:"operatingSystem"`

	Username string `json:"username" yaml:"username"`

	Password string `json:"password" yaml:"password"`

	NuixPath string `json:"nuixPath" yaml:"nuixPath"`

	SkipInstall bool `json:"skipInstall" yaml:"skipInstall"`
}

// ServerApplyResponse is the output-object for Apply in the server-service
type ServerApplyResponse struct {
	Server Server `json:"server" yaml:"server"`
}

// ServerListRequest is the input-object for List in the server-service
type ServerListRequest struct {
}

// ServerListResponse is the output-object for List in the server-service
type ServerListResponse struct {
	Servers []Server `json:"servers" yaml:"servers"`
}

// Type holds information for a type
type Type struct {
	datastore.Base

	// PopulateID foreign-key for populate-table
	PopulateID uint `json:"populateID" yaml:"populateID"`

	// Type-name
	Type string `json:"type" yaml:"type"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

func generateSignature(message, secret []byte) (string, error) {
	mac := hmac.New(sha256.New, secret)
	if _, err := mac.Write(message); err != nil {
		return "", err
	}
	sig := base64.StdEncoding.EncodeToString(mac.Sum(nil))
	return sig, nil
}
