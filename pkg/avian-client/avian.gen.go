// Code generated by oto; DO NOT EDIT.
// Generated from plush template file at generate/templates/client.go.plush

package avian

import (
	"bytes"
	"compress/gzip"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strings"

	datastore "github.com/avian-digital-forensics/auto-processing/pkg/datastore"
	inapp "github.com/avian-digital-forensics/auto-processing/pkg/inapp"
	"github.com/pkg/errors"
	time "time"
)

// Client is used to access Pace services.
type Client struct {
	// RemoteHost is the URL of the remote server that this Client should
	// access.
	RemoteHost string
	// HTTPClient is the http.Client to use when making HTTP requests.
	HTTPClient *http.Client
	// Debug writes a line of debug log output.
	Debug func(s string)
	// secret is the Secret to make the HMAC signature
	secret []byte
}

// New makes a new Client.
func New(remoteHost, secret string) *Client {
	return &Client{
		RemoteHost: remoteHost,
		Debug:      func(s string) {},
		// No timeout is set to HTTPClient
		// since some operations takes too long
		HTTPClient: &http.Client{},
		secret:     []byte(secret),
	}
}

// NmsService handles the Nuix Management Servers
type NmsService struct {
	client *Client
}

// NewNmsService makes a new client for accessing NmsService services.
func NewNmsService(client *Client) *NmsService {
	return &NmsService{
		client: client,
	}
}

func (s *NmsService) Apply(ctx context.Context, r NmsApplyRequests) (*NmsApplyResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.Apply: marshal NmsApplyRequests")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.Apply: generate signature NmsApplyRequests")
	}
	url := s.client.RemoteHost + "NmsService.Apply"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.Apply: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.Apply")
	}
	defer resp.Body.Close()
	var response struct {
		NmsApplyResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "NmsService.Apply: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.Apply: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("NmsService.Apply: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.NmsApplyResponse, nil
}

func (s *NmsService) List(ctx context.Context, r NmsListRequest) (*NmsListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.List: marshal NmsListRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.List: generate signature NmsListRequest")
	}
	url := s.client.RemoteHost + "NmsService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.List: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.List")
	}
	defer resp.Body.Close()
	var response struct {
		NmsListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "NmsService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.List: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("NmsService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.NmsListResponse, nil
}

func (s *NmsService) ListLicences(ctx context.Context, r NmsListLicencesRequest) (*NmsListLicencesResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.ListLicences: marshal NmsListLicencesRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.ListLicences: generate signature NmsListLicencesRequest")
	}
	url := s.client.RemoteHost + "NmsService.ListLicences"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.ListLicences: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.ListLicences")
	}
	defer resp.Body.Close()
	var response struct {
		NmsListLicencesResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "NmsService.ListLicences: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "NmsService.ListLicences: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("NmsService.ListLicences: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.NmsListLicencesResponse, nil
}

// RunnerService handles all the runners
type RunnerService struct {
	client *Client
}

// NewRunnerService makes a new client for accessing RunnerService services.
func NewRunnerService(client *Client) *RunnerService {
	return &RunnerService{
		client: client,
	}
}

// Apply applies the configuration to the backend
func (s *RunnerService) Apply(ctx context.Context, r RunnerApplyRequest) (*RunnerApplyResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Apply: marshal RunnerApplyRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Apply: generate signature RunnerApplyRequest")
	}
	url := s.client.RemoteHost + "RunnerService.Apply"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Apply: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Apply")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerApplyResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.Apply: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Apply: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.Apply: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerApplyResponse, nil
}

// Delete deletes the requested Runner
func (s *RunnerService) Delete(ctx context.Context, r RunnerDeleteRequest) (*RunnerDeleteResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Delete: marshal RunnerDeleteRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Delete: generate signature RunnerDeleteRequest")
	}
	url := s.client.RemoteHost + "RunnerService.Delete"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Delete: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Delete")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerDeleteResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.Delete: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Delete: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.Delete: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerDeleteResponse, nil
}

// Failed sets a runner to failed
func (s *RunnerService) Failed(ctx context.Context, r RunnerFailedRequest) (*RunnerFailedResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Failed: marshal RunnerFailedRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Failed: generate signature RunnerFailedRequest")
	}
	url := s.client.RemoteHost + "RunnerService.Failed"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Failed: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Failed")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerFailedResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.Failed: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Failed: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.Failed: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerFailedResponse, nil
}

// FailedStage sets a stage to Failed
func (s *RunnerService) FailedStage(ctx context.Context, r StageRequest) (*StageResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FailedStage: marshal StageRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FailedStage: generate signature StageRequest")
	}
	url := s.client.RemoteHost + "RunnerService.FailedStage"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FailedStage: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FailedStage")
	}
	defer resp.Body.Close()
	var response struct {
		StageResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.FailedStage: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FailedStage: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.FailedStage: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.StageResponse, nil
}

// Finish sets a runner to finished
func (s *RunnerService) Finish(ctx context.Context, r RunnerFinishRequest) (*RunnerFinishResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Finish: marshal RunnerFinishRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Finish: generate signature RunnerFinishRequest")
	}
	url := s.client.RemoteHost + "RunnerService.Finish"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Finish: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Finish")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerFinishResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.Finish: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Finish: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.Finish: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerFinishResponse, nil
}

// FinishStage sets a stage to Finished
func (s *RunnerService) FinishStage(ctx context.Context, r StageRequest) (*StageResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FinishStage: marshal StageRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FinishStage: generate signature StageRequest")
	}
	url := s.client.RemoteHost + "RunnerService.FinishStage"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FinishStage: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FinishStage")
	}
	defer resp.Body.Close()
	var response struct {
		StageResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.FinishStage: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.FinishStage: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.FinishStage: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.StageResponse, nil
}

// Get returns the requested Runner
func (s *RunnerService) Get(ctx context.Context, r RunnerGetRequest) (*RunnerGetResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Get: marshal RunnerGetRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Get: generate signature RunnerGetRequest")
	}
	url := s.client.RemoteHost + "RunnerService.Get"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Get: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Get")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerGetResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.Get: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Get: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.Get: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerGetResponse, nil
}

// Heartbeat sends a heartbeat for the api
func (s *RunnerService) Heartbeat(ctx context.Context, r RunnerStartRequest) (*RunnerStartResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Heartbeat: marshal RunnerStartRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Heartbeat: generate signature RunnerStartRequest")
	}
	url := s.client.RemoteHost + "RunnerService.Heartbeat"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Heartbeat: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Heartbeat")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerStartResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.Heartbeat: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Heartbeat: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.Heartbeat: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerStartResponse, nil
}

// List returns the runners from the backend
func (s *RunnerService) List(ctx context.Context, r RunnerListRequest) (*RunnerListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.List: marshal RunnerListRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.List: generate signature RunnerListRequest")
	}
	url := s.client.RemoteHost + "RunnerService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.List: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.List")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.List: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerListResponse, nil
}

// LogDebug logs a debug-message
func (s *RunnerService) LogDebug(ctx context.Context, r LogRequest) (*LogResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogDebug: marshal LogRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogDebug: generate signature LogRequest")
	}
	url := s.client.RemoteHost + "RunnerService.LogDebug"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogDebug: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogDebug")
	}
	defer resp.Body.Close()
	var response struct {
		LogResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.LogDebug: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogDebug: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.LogDebug: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LogResponse, nil
}

// LogError logs an error-message
func (s *RunnerService) LogError(ctx context.Context, r LogRequest) (*LogResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogError: marshal LogRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogError: generate signature LogRequest")
	}
	url := s.client.RemoteHost + "RunnerService.LogError"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogError: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogError")
	}
	defer resp.Body.Close()
	var response struct {
		LogResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.LogError: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogError: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.LogError: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LogResponse, nil
}

// LogInfo logs an info-message
func (s *RunnerService) LogInfo(ctx context.Context, r LogRequest) (*LogResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogInfo: marshal LogRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogInfo: generate signature LogRequest")
	}
	url := s.client.RemoteHost + "RunnerService.LogInfo"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogInfo: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogInfo")
	}
	defer resp.Body.Close()
	var response struct {
		LogResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.LogInfo: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogInfo: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.LogInfo: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LogResponse, nil
}

// LogItem logs an item
func (s *RunnerService) LogItem(ctx context.Context, r LogItemRequest) (*LogResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogItem: marshal LogItemRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogItem: generate signature LogItemRequest")
	}
	url := s.client.RemoteHost + "RunnerService.LogItem"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogItem: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogItem")
	}
	defer resp.Body.Close()
	var response struct {
		LogResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.LogItem: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.LogItem: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.LogItem: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.LogResponse, nil
}

// Script returns the script for the runner
func (s *RunnerService) Script(ctx context.Context, r RunnerGetRequest) (*RunnerScriptResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Script: marshal RunnerGetRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Script: generate signature RunnerGetRequest")
	}
	url := s.client.RemoteHost + "RunnerService.Script"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Script: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Script")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerScriptResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.Script: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Script: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.Script: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerScriptResponse, nil
}

// Start sets a runner to started
func (s *RunnerService) Start(ctx context.Context, r RunnerStartRequest) (*RunnerStartResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Start: marshal RunnerStartRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Start: generate signature RunnerStartRequest")
	}
	url := s.client.RemoteHost + "RunnerService.Start"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Start: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Start")
	}
	defer resp.Body.Close()
	var response struct {
		RunnerStartResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.Start: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.Start: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.Start: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.RunnerStartResponse, nil
}

// StartStage sets a stage to Active
func (s *RunnerService) StartStage(ctx context.Context, r StageRequest) (*StageResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.StartStage: marshal StageRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.StartStage: generate signature StageRequest")
	}
	url := s.client.RemoteHost + "RunnerService.StartStage"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.StartStage: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.StartStage")
	}
	defer resp.Body.Close()
	var response struct {
		StageResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.StartStage: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.StartStage: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.StartStage: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.StageResponse, nil
}

func (s *RunnerService) UploadFile(ctx context.Context, r UploadFileRequest) (*UploadFileResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.UploadFile: marshal UploadFileRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.UploadFile: generate signature UploadFileRequest")
	}
	url := s.client.RemoteHost + "RunnerService.UploadFile"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.UploadFile: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.UploadFile")
	}
	defer resp.Body.Close()
	var response struct {
		UploadFileResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "RunnerService.UploadFile: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "RunnerService.UploadFile: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("RunnerService.UploadFile: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UploadFileResponse, nil
}

// ServerService handles all the servers
type ServerService struct {
	client *Client
}

// NewServerService makes a new client for accessing ServerService services.
func NewServerService(client *Client) *ServerService {
	return &ServerService{
		client: client,
	}
}

func (s *ServerService) Apply(ctx context.Context, r ServerApplyRequest) (*ServerApplyResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.Apply: marshal ServerApplyRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.Apply: generate signature ServerApplyRequest")
	}
	url := s.client.RemoteHost + "ServerService.Apply"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.Apply: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.Apply")
	}
	defer resp.Body.Close()
	var response struct {
		ServerApplyResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "ServerService.Apply: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.Apply: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("ServerService.Apply: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.ServerApplyResponse, nil
}

func (s *ServerService) List(ctx context.Context, r ServerListRequest) (*ServerListResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.List: marshal ServerListRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.List: generate signature ServerListRequest")
	}
	url := s.client.RemoteHost + "ServerService.List"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.List: NewRequest")
	}
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.List")
	}
	defer resp.Body.Close()
	var response struct {
		ServerListResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "ServerService.List: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "ServerService.List: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("ServerService.List: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.ServerListResponse, nil
}

// Case holds the information for a case
type Case struct {
	datastore.Base

	// Name of the case
	Name string `json:"name" yaml:"name"`

	// Directory of the case
	Directory string `json:"directory" yaml:"directory"`

	// Description of the case
	Description string `json:"description" yaml:"description"`

	// Investigator of the case
	Investigator string `json:"investigator" yaml:"investigator"`

	ElasticSearchID uint `json:"elasticSearchID" yaml:"elasticSearchID"`

	ElasticSearch *Elasticsearch `json:"elasticSearch" yaml:"elasticSearch"`
}

// CaseSettings holds information about the cases if Processing-stage is used for a
// Runner
type CaseSettings struct {
	datastore.Base

	// CaseLocation is the parent-folder for all cases
	CaseLocation string `json:"caseLocation" yaml:"caseLocation"`

	// Case holds the information for the single-case
	CaseID uint `json:"caseID" yaml:"caseID"`

	Case *Case `json:"case" yaml:"case"`

	// CompoundCase holds the information for the compound-case
	CompoundCaseID uint `json:"compoundCaseID" yaml:"compoundCaseID"`

	CompoundCase *Case `json:"compoundCase" yaml:"compoundCase"`

	// ReviewCompound holds the information for the review-compound
	ReviewCompoundID uint `json:"reviewCompoundID" yaml:"reviewCompoundID"`

	ReviewCompound *Case `json:"reviewCompound" yaml:"reviewCompound"`
}

type Elasticsearch struct {
	datastore.Base

	ClusterName string `json:"clusterName" yaml:"clusterName"`

	NuixTransportHost string `json:"nuixTransportHost" yaml:"nuixTransportHost"`

	IndexNumberOfReplicas int `json:"indexNumberOfReplicas" yaml:"indexNumberOfReplicas"`

	IndexNumberOfShards int `json:"indexNumberOfShards" yaml:"indexNumberOfShards"`
}

// Evidence holds information about a specific evidence
type Evidence struct {
	datastore.Base

	// ProcessID foreign-key for process-table
	ProcessID uint `json:"processID" yaml:"processID"`

	// Name of the evidence
	Name string `json:"name" yaml:"name"`

	// Directory of where the evidence is located
	Directory string `json:"directory" yaml:"directory"`

	// Description of the evidence
	Description string `json:"description" yaml:"description"`

	// Encoding for the evidence (used when processing)
	Encoding string `json:"encoding" yaml:"encoding"`

	// TimeZone for the evidence
	TimeZone string `json:"timeZone" yaml:"timeZone"`

	// Custodian for the evidence
	Custodian string `json:"custodian" yaml:"custodian"`

	// Locale for the evidence (used when processing)
	Locale string `json:"locale" yaml:"locale"`
}

// Exclude excludes items in a Nuix-case based on a search
type Exclude struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Search query in the case
	Search string `json:"search" yaml:"search"`

	// Reason to exclude the items from the search
	Reason string `json:"reason" yaml:"reason"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// File holds information about a file
type File struct {
	datastore.Base

	// SearchAndTagID foreign-key for searchandtag-table
	SearchAndTagID uint `json:"searchAndTagID" yaml:"searchAndTagID"`

	// Path for where the file is located at
	Path string `json:"path" yaml:"path"`
}

// InApp script as a stage
type InApp struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Name for in-app script
	Name string `json:"name" yaml:"name"`

	// Config for in-app script
	Config string `json:"config" yaml:"config"`

	// Settings decoded from the config-file provided in Config-field
	Settings inapp.Settings `json:"settings" yaml:"settings"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Licence holds information about licences in Nuix Management Server
type Licence struct {
	datastore.Base

	// Foreign-key for the NMS-server
	NmsID uint `json:"nmsID" yaml:"nmsID"`

	// Type of licence
	Type string `json:"type" yaml:"type"`

	// Amount of licences for this type
	Amount int64 `json:"amount" yaml:"amount"`

	// Amount of licenses in use for this type
	InUse int64 `json:"inUse" yaml:"inUse"`
}

// LicenceApplyRequest is the input-object for applying NMS-licence
type LicenceApplyRequest struct {

	// Type of licence
	Type string `json:"type" yaml:"type"`

	// Amount of licences for this type
	Amount int64 `json:"amount" yaml:"amount"`
}

// Licences is a holder for Licence
type Licences struct {
	Licence LicenceApplyRequest `json:"licence" yaml:"licence"`
}

type LogItemRequest struct {
	Runner string `json:"runner" yaml:"runner"`

	Stage string `json:"stage" yaml:"stage"`

	StageID int `json:"stageID" yaml:"stageID"`

	Message string `json:"message" yaml:"message"`

	Count int `json:"count" yaml:"count"`

	MimeType string `json:"mimeType" yaml:"mimeType"`

	GUID string `json:"gUID" yaml:"gUID"`

	ProcessStage string `json:"processStage" yaml:"processStage"`

	IsCorrupted bool `json:"isCorrupted" yaml:"isCorrupted"`

	IsDeleted bool `json:"isDeleted" yaml:"isDeleted"`

	IsEncrypted bool `json:"isEncrypted" yaml:"isEncrypted"`
}

type LogRequest struct {
	Runner string `json:"runner" yaml:"runner"`

	Stage string `json:"stage" yaml:"stage"`

	StageID int `json:"stageID" yaml:"stageID"`

	Message string `json:"message" yaml:"message"`

	Exception string `json:"exception" yaml:"exception"`
}

type LogResponse struct {
}

// Nms is the main struct for the Nuix Management Servers
type Nms struct {
	datastore.Base

	// Address of the nms-server
	Address string `json:"address" yaml:"address"`

	// Port for the nms-server
	Port int64 `json:"port" yaml:"port"`

	// Username for the nms-server
	Username string `json:"username" yaml:"username"`

	// Password for the nms-server
	Password string `json:"password" yaml:"password"`

	// amount of workers licensed to the server
	Workers int64 `json:"workers" yaml:"workers"`

	// Amount of workers in use
	InUse int64 `json:"inUse" yaml:"inUse"`

	// Licences available at the server
	Licences []Licence `json:"licences" yaml:"licences"`
}

// NmsApplyRequest is the input-object for Apply in the NMS-service
type NmsApplyRequest struct {

	// Address of the nms-server
	Address string `json:"address" yaml:"address"`

	// Port for the nms-server
	Port int64 `json:"port" yaml:"port"`

	// Username for the nms-server
	Username string `json:"username" yaml:"username"`

	// Password for the nms-server
	Password string `json:"password" yaml:"password"`

	// amount of workers licensed to the server
	Workers int64 `json:"workers" yaml:"workers"`

	// Licences available at the server
	Licences []Licences `json:"licences" yaml:"licences"`
}

type NmsApplyRequests struct {
	Nms []NmsApplyRequest `json:"nms" yaml:"nms"`
}

// NmsApplyResponse is the output-object for Apply in the NMS-service
type NmsApplyResponse struct {
	Nms []Nms `json:"nms" yaml:"nms"`
}

// NmsListLicencesRequest is the input-object for listing licences for a specific
// NMS
type NmsListLicencesRequest struct {

	// ID for the nms-server to list the licences for
	NmsID uint `json:"nmsID" yaml:"nmsID"`
}

// NmsListLicencesResponse is the output-object for listing licences for a specific
// NMS
type NmsListLicencesResponse struct {
	Licences []Licence `json:"licences" yaml:"licences"`
}

// NmsListRequest is the input-object for List in the NMS-service
type NmsListRequest struct {
}

// NmsListResponse is the output-object for List in the NMS-service
type NmsListResponse struct {
	Nms []Nms `json:"nms" yaml:"nms"`
}

// NuixSwitch is a command argument for nuix-console
type NuixSwitch struct {
	datastore.Base

	RunnerID uint `json:"runnerID" yaml:"runnerID"`

	Value string `json:"value" yaml:"value"`
}

// Ocr performs OCR based on a search in a Nuix-case
type Ocr struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Profile for the ocr-processor
	Profile string `json:"profile" yaml:"profile"`

	ProfilePath string `json:"profilePath" yaml:"profilePath"`

	// Search query in the case
	Search string `json:"search" yaml:"search"`

	// BatchSize for items
	BatchSize int `json:"batchSize" yaml:"batchSize"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Populate populates data based on a search in a Nuix-case
type Populate struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Search query in the case
	Search string `json:"search" yaml:"search"`

	// Types for the items to populate
	Types []*Type `json:"types" yaml:"types"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Process -stage processes data into a Nuix-case
type Process struct {
	datastore.Base

	// Foreign-key for stage
	StageID uint `json:"stageID" yaml:"stageID"`

	// Profile for the processor
	Profile string `json:"profile" yaml:"profile"`

	ProfilePath string `json:"profilePath" yaml:"profilePath"`

	// EvidenceStore to process to the nuix-case
	EvidenceStore []*Evidence `json:"evidenceStore" yaml:"evidenceStore"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Reload reloads items in a Nuix-case based on a search
type Reload struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Profile for the reload-processing
	Profile string `json:"profile" yaml:"profile"`

	ProfilePath string `json:"profilePath" yaml:"profilePath"`

	// Search query in the case
	Search string `json:"search" yaml:"search"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Runner holds the information for a specific runner
type Runner struct {
	datastore.Base

	// Name for the runner
	Name string `json:"name" yaml:"name"`

	// Server to use for the runner
	Hostname string `json:"hostname" yaml:"hostname"`

	// Nms to use for the runner
	Nms string `json:"nms" yaml:"nms"`

	// Licence to use for the runner
	Licence string `json:"licence" yaml:"licence"`

	// Xmx to use for the runner
	Xmx string `json:"xmx" yaml:"xmx"`

	// Amount of workers to use for the runner
	Workers int64 `json:"workers" yaml:"workers"`

	// Active - if the runner is active or not
	Active bool `json:"active" yaml:"active"`

	// Status for the runner
	Status int64 `json:"status" yaml:"status"`

	// HealthyAt - last time the runner was healthy
	HealthyAt *time.Time `json:"healthyAt" yaml:"healthyAt"`

	// CaseSettings for the cases to use
	CaseSettingsID uint `json:"caseSettingsID" yaml:"caseSettingsID"`

	CaseSettings *CaseSettings `json:"caseSettings" yaml:"caseSettings"`

	// Stages for the runner
	Stages []*Stage `json:"stages" yaml:"stages"`

	// Switches to use for nuix-console
	Switches []*NuixSwitch `json:"switches" yaml:"switches"`

	CaseID string `json:"caseID" yaml:"caseID"`
}

// RunnerApplyRequest is the input-object for applying a runner-configuration to
// the Runner-service
type RunnerApplyRequest struct {

	// Name for the runner
	Name string `json:"name" yaml:"name"`

	// Server to use for the runner
	Hostname string `json:"hostname" yaml:"hostname"`

	// Nms to use for the runner
	Nms string `json:"nms" yaml:"nms"`

	// Licence to use for the runner
	Licence string `json:"licence" yaml:"licence"`

	// Xmx to use for the runner
	Xmx string `json:"xmx" yaml:"xmx"`

	// Amount of workers to use for the runner
	Workers int64 `json:"workers" yaml:"workers"`

	// CaseSettings is the settings for the cases that should be processed if
	// Process-stage is used
	CaseSettings *CaseSettings `json:"caseSettings" yaml:"caseSettings"`

	// Stages for the runner
	Stages []*Stage `json:"stages" yaml:"stages"`

	// Switches to use for nuix-console
	Switches []string `json:"switches" yaml:"switches"`

	// Update - if the runner should be updated
	Update bool `json:"update" yaml:"update"`
}

// RunnerApplyResponse is the output-object for applying a runner-configuration to
// the backend
type RunnerApplyResponse struct {
	Runner Runner `json:"runner" yaml:"runner"`
}

// RunnerDeleteRequest is the input-object for deleting a runner by name
type RunnerDeleteRequest struct {

	// Name of the runner
	Name string `json:"name" yaml:"name"`

	// DeleteCase - if the user wants to delete the case for the runner
	DeleteCase bool `json:"deleteCase" yaml:"deleteCase"`

	// DeleteAllCases - if the user wants to delete all cases for the runner
	DeleteAllCases bool `json:"deleteAllCases" yaml:"deleteAllCases"`

	// Force - if the delete should be forced
	Force bool `json:"force" yaml:"force"`
}

// RunnerDeleteResponse is the output-object for deleting a runner by name
type RunnerDeleteResponse struct {
}

// RunnerFailedRequest is the input-object for failing a runner by id
type RunnerFailedRequest struct {
	ID uint `json:"id" yaml:"id"`

	Runner string `json:"runner" yaml:"runner"`

	Exception string `json:"exception" yaml:"exception"`
}

// RunnerFailedResponse is the output-object for failing a runner by id
type RunnerFailedResponse struct {
}

// RunnerFinishRequest is the input-object for finishing a runner by id
type RunnerFinishRequest struct {
	ID uint `json:"id" yaml:"id"`

	Runner string `json:"runner" yaml:"runner"`
}

// RunnerFinishResponse is the output-object for finishing a runner by id
type RunnerFinishResponse struct {
}

// RunnerGetRequest is the input-object for requesting a runner by name
type RunnerGetRequest struct {
	Name string `json:"name" yaml:"name"`
}

// RunnerGetResponse is the output-object for requesting a runner by name
type RunnerGetResponse struct {
	Runner Runner `json:"runner" yaml:"runner"`
}

// RunnerListRequest is the input-object for listing the runners from the backend
type RunnerListRequest struct {
}

// RunnerListResponse is the input-object for listing the runners from the backend
type RunnerListResponse struct {
	Runners []Runner `json:"runners" yaml:"runners"`
}

// RunnerScriptResponse is the output-object for GetScript
type RunnerScriptResponse struct {
	Script string `json:"script" yaml:"script"`
}

type StageRequest struct {
	Runner string `json:"runner" yaml:"runner"`

	StageID uint `json:"stageID" yaml:"stageID"`
}

// Stage holds different types of stages for a Runner
type Stage struct {
	datastore.Base

	// Foreign-key for runners
	RunnerID uint `json:"runnerID" yaml:"runnerID"`

	// Index for where the stage where indexed in the yaml
	Index uint `json:"index" yaml:"index"`

	// Process-stage processes data into a Nuix-case
	Process *Process `json:"process" yaml:"process"`

	// SearchAndTag searches and tags data in a Nuix-case
	SearchAndTag *SearchAndTag `json:"searchAndTag" yaml:"searchAndTag"`

	// Populate populates data based on a search in a Nuix-case
	Populate *Populate `json:"populate" yaml:"populate"`

	// Ocr performs OCR based on a search in a Nuix-case
	Ocr *Ocr `json:"ocr" yaml:"ocr"`

	// Exclude excludes items in a Nuix-case based on a search
	Exclude *Exclude `json:"exclude" yaml:"exclude"`

	// Reload reloads items in a Nuix-case based on a search
	Reload *Reload `json:"reload" yaml:"reload"`

	// InApp is a stage for avian in-app scripts
	InApp *InApp `json:"inApp" yaml:"inApp"`

	// SyncDescendants syncs descendants for the specified items
	SyncDescendants *SyncDescendants `json:"syncDescendants" yaml:"syncDescendants"`

	// ScanNewChildItems scans for new child items based on a search
	ScanNewChildItems *ScanNewChildItems `json:"scanNewChildItems" yaml:"scanNewChildItems"`
}

type StageResponse struct {
	Stage Stage `json:"stage" yaml:"stage"`
}

// RunnerStartRequest is the input-object for starting a runner by id
type RunnerStartRequest struct {
	ID uint `json:"id" yaml:"id"`

	Runner string `json:"runner" yaml:"runner"`

	CaseID string `json:"caseID" yaml:"caseID"`
}

// RunnerStartResponse is the output-object for starting a runner by id
type RunnerStartResponse struct {
}

type UploadFileRequest struct {
	Name string `json:"name" yaml:"name"`

	Description string `json:"description" yaml:"description"`

	Content []byte `json:"content" yaml:"content"`
}

type UploadFileResponse struct {
	Path string `json:"path" yaml:"path"`
}

type ScanNewChildItems struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Profile for processing
	Profile string `json:"profile" yaml:"profile"`

	// Search for the items to sync
	Search string `json:"search" yaml:"search"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// SearchAndTag searches and tags data in a Nuix-case
type SearchAndTag struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Search query in the case
	Search string `json:"search" yaml:"search"`

	// Tag for the items from the search
	Tag string `json:"tag" yaml:"tag"`

	// Files for the search-and-tag
	Files []*File `json:"files" yaml:"files"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Server is the main-struct for the servers
type Server struct {
	datastore.Base

	// Hostname of the server
	Hostname string `json:"hostname" yaml:"hostname"`

	// Port for the server
	Port int64 `json:"port" yaml:"port"`

	// OperatingSystem the server is running
	OperatingSystem string `json:"operatingSystem" yaml:"operatingSystem"`

	// Username for connection to the server
	Username string `json:"username" yaml:"username"`

	// Password for connection to the server
	Password string `json:"password" yaml:"password"`

	// NuixPath to know where to run Nuix
	NuixPath string `json:"nuixPath" yaml:"nuixPath"`

	// AvianScripts path to the avian-scripts
	AvianScripts string `json:"avianScripts" yaml:"avianScripts"`

	// Active - if the server has an active job
	Active bool `json:"active" yaml:"active"`
}

// ServerApplyRequest is the input-object for Apply in the server-service
type ServerApplyRequest struct {
	Hostname string `json:"hostname" yaml:"hostname"`

	Port int64 `json:"port" yaml:"port"`

	OperatingSystem string `json:"operatingSystem" yaml:"operatingSystem"`

	Username string `json:"username" yaml:"username"`

	Password string `json:"password" yaml:"password"`

	NuixPath string `json:"nuixPath" yaml:"nuixPath"`

	AvianScripts string `json:"avianScripts" yaml:"avianScripts"`
}

// ServerApplyResponse is the output-object for Apply in the server-service
type ServerApplyResponse struct {
	Server Server `json:"server" yaml:"server"`
}

// ServerListRequest is the input-object for List in the server-service
type ServerListRequest struct {
}

// ServerListResponse is the output-object for List in the server-service
type ServerListResponse struct {
	Servers []Server `json:"servers" yaml:"servers"`
}

type SyncDescendants struct {
	datastore.Base

	// StageID foreign-key for stage-table
	StageID uint `json:"stageID" yaml:"stageID"`

	// Search for the items to sync
	Search string `json:"search" yaml:"search"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

// Type holds information for a type
type Type struct {
	datastore.Base

	// PopulateID foreign-key for populate-table
	PopulateID uint `json:"populateID" yaml:"populateID"`

	// Type-name
	Type string `json:"type" yaml:"type"`

	// Status for the stage
	Status int64 `json:"status" yaml:"status"`
}

func generateSignature(message, secret []byte) (string, error) {
	mac := hmac.New(sha256.New, secret)
	if _, err := mac.Write(message); err != nil {
		return "", err
	}
	sig := base64.StdEncoding.EncodeToString(mac.Sum(nil))
	return sig, nil
}
